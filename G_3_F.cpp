/***********************************************************************
 * Моля, преименувате файла, като:
 *   - замените G с групата, с която ходите на упражнения
 *   - замените F с вашия факултетен номер
 **********************************************************************/

/***********************************************************************
Задача 3. Разглеждаме списък от опашки от числа, в които елементите са 
подредени в монотонно нарастващ ред. Да се реализира функция, която 
прехвърля елементите на опашките, които са на четни позиции в списъка, 
в нова опашка така, че числата в нея да са подредени в монотонно 
нарастващ ред. Новата опашка да се запише на последна позиция в списъка, 
а изпразнените опашки да се изтрият от списъка. Представянето на списъка 
от опашки е по ваш избор. Бонус: използвайте шаблони, така че елементите 
да могат да са от произволен тип.
Пример:

Вход
       -2     	 
-1     -1     	 
 0      2      3      1
 3  –>  5  ->  7  ->  4

Изход
               -2
               -1
                1
 -1             2
  0      3	    4
  3  ->  7  ->  5
************************************************************************/

/***********************************************************************
 РЕШЕНИЕ:
************************************************************************/
#include "linked_queue.hpp"
#include "linked_list.hpp"

template <typename T>
void transform(LinkedList<LinkedQueue<T>>& lq) {
    LinkedQueue<T> result;
    LinkedQueue<T>* minq = nullptr;
    typename LinkedList<LinkedQueue<T>>::Iterator it;
    
    do {
        it = lq.begin();
        minq = nullptr;
        
        for (int pos = 1; it != lq.end(); ++it, ++pos) {
            if (pos % 2 == 0 && !(*it).empty()) {
                if (minq == nullptr || (*it).head() < minq->head())
                    minq = &*it;
            }
        }
        
        if (minq != nullptr)
            result.enqueue((*minq).dequeue());
    } while (minq != nullptr);
    
    it = lq.begin();
    for (int pos = 2; it != lq.end(); ++pos)
        if (pos % 2 == 0) {
            LinkedQueue<T> tmp;
            lq.deleteAfter(tmp, it);
        }
        else
            ++it;
    
    lq.insertLast(result);
}

/***********************************************************************
 КРАЙ НА РЕШЕНИЕТО
************************************************************************/

#define DOCTEST_CONFIG_IMPLEMENT
#include "doctest.h"

/***********************************************************************
  РАЗКОМЕНТИРАЙТЕ СЛЕДВАЩИЯ РЕД, ЗА ДА ВКЛЮЧИТЕ ТЕСТОВЕТЕ
************************************************************************/
#include "3_tests.hpp"

int main () {
    // пускане на тестовете
    doctest::Context().run();
    return 0;
}
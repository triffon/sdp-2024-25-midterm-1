/***********************************************************************
 * Моля, преименувате файла, като:
 *   - замените G с групата, с която ходите на упражнения
 *   - замените F с вашия факултетен номер
 **********************************************************************/

/***********************************************************************
Задача 6. Разглеждаме списък от стекове от числа, в които елементите са 
подредени в монотонно нарастващ ред от върха към дъното. Да се реализира 
функция, която прехвърля елементите на стековете, които са на нечетни 
позиции в списъка, в нов стек така, че числата в него да са подредени в 
монотонно намаляващ ред от върха към дъното. Новият стек да се запише на 
първа позиция в списъка, а изпразнените стекове да се изтрият от списъка. 
Представянето на списъка от стекове е по ваш избор.
Бонус: използвайте шаблони, така че елементите да могат да са от произволен 
тип.
Пример:

Вход
                4	 
 3              2      7
 2      3       0      4
 1  –>  0  ->  -1  ->  0

Изход
 -1              
  0             
  1             
  2             
  2      	    7
  3      3      4
  4  ->  0  ->  0
************************************************************************/

/***********************************************************************
 РЕШЕНИЕ:
************************************************************************/
#include <stack>
#include <list>

template <typename T>
void transform(std::list<std::stack<T>>& ls) {
    std::stack<T> result;
    std::stack<T>* mins = nullptr;
    typename std::list<std::stack<T>>::iterator it;
    
    do {
        it = ls.begin();
        mins = nullptr;
        
        for (int pos = 1; it != ls.end(); ++it, ++pos) {
            if (pos % 2 != 0 && !it->empty()) {
                if (mins == nullptr || it->top() < mins->top())
                    mins = &*it;
            }
        }
        
        if (mins != nullptr) {
            result.push(mins->top());
            mins->pop();
        }
    } while (mins != nullptr);

    it = ls.begin();
    for (int pos = 1; it != ls.end(); ++pos)
        if (pos % 2 != 0)
            it = ls.erase(it);
        else
            ++it;

    it = ls.begin();
    ls.push_front(result);
}
/***********************************************************************
 КРАЙ НА РЕШЕНИЕТО
************************************************************************/

#define DOCTEST_CONFIG_IMPLEMENT
#include "doctest.h"

/***********************************************************************
  РАЗКОМЕНТИРАЙТЕ СЛЕДВАЩИЯ РЕД, ЗА ДА ВКЛЮЧИТЕ ТЕСТОВЕТЕ
************************************************************************/
#include "6_tests_stl.hpp"

int main () {
    // пускане на тестовете
    doctest::Context().run();
    return 0;
}
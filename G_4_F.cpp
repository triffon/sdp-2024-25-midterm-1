/***********************************************************************
 * Моля, преименувате файла, като:
 *   - замените G с групата, с която ходите на упражнения
 *   - замените F с вашия факултетен номер
 **********************************************************************/

/***********************************************************************
Задача 4. Иванчо много обича да гледа видеа в платформата MeTelly, но има
специални предпочитания: минава поред по видеата, които му предлага 
платформата, и след като изгледа първото видео, всяко следващо трябва да е с 
повече гледания от предишното, в противен случай го запазва накрая на списъка
си с видеа за по-късно и минава нататък. Ако се случи n последователни видеа
да няма следващо с по-висок брой гледания, на Иванчо му доскучава и спира да
гледа.
Да се реализира функция [опашка] watch(int n, [опашка] play, [опашка] later), 
която по подадена опашка от видеа за гледане play връща опашка последователно 
заглавията на гледаните от Иванчо видеа и записва в опашката later заглавията
на видеата, които е запазил за по-късно, в реда, в който ги е запазил.
Представянето на опашките и видеата в тях е по ваш избор.
Пример: watch(2, {{"APT",34}, {"Лeкция по СДП",2},{"Gangnam style",531},
{"Despacito",856}, {"Shape of you",634}, {"Baby",320}, {"Baby shark",1517}, 
later) ⇒ {"APT", "Gangnam style", "Despacito"}
В later се записват {"Лeкция по СДП", "Shape of you", "Baby"}
************************************************************************/

/***********************************************************************
 РЕШЕНИЕ:
************************************************************************/
#include "linked_queue.hpp"

using Video = std::pair<std::string, int>;

LinkedQueue<std::string> watch(int n, LinkedQueue<Video> play, LinkedQueue<std::string>& later) {
    LinkedQueue<std::string> result;
    Video current = play.dequeue();
    Video last = current;
    result.enqueue(current.first);
    int skipped = 0;
    
    while (!play.empty() && skipped < n) {
        current = play.dequeue();
        if (current.second > last.second) {
            result.enqueue(current.first);
            skipped = 0;
        } else {
            later.enqueue(current.first);
            ++skipped;
        }
        last = current;
    }
    
    return result;
}

/***********************************************************************
 КРАЙ НА РЕШЕНИЕТО
************************************************************************/

#define DOCTEST_CONFIG_IMPLEMENT
#include "doctest.h"

/***********************************************************************
  РАЗКОМЕНТИРАЙТЕ СЛЕДВАЩИЯ РЕД, ЗА ДА ВКЛЮЧИТЕ ТЕСТОВЕТЕ
************************************************************************/
#include "4_tests.hpp"

int main () {
    // пускане на тестовете
    doctest::Context().run();
    return 0;
}